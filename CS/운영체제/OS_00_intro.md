# OS_00_intro

## 운영체제란?

> 컴퓨터 하드웨어를 관리하는 프로그램 Control Program for Computer

- 컴퓨터 = Processor(처리기) + Main Memory(주 기억장치)
- 컴퓨터 전원을 켜면 프로세서가 메모리에 있는 명령을 들고와서 실행, 다음 명령을 들고 와서 실행하는 식으로 작동
- 메모리에 명령(Instruction)을 기록해둬야함. 이때 운영체제가 없다면 메모리에 임의의 값이 들어가게 된다. (프로그램 = 명령들의 집합)
- 메모리는 휘발성이기 때문에 기본적으로 실행 프로그램들은 하드디스크에 저장되어 있다.
- OS가 있어야 하드에 있는 실행 프로그램을 메모리로 올릴 수 있다
- 또한 여러 개의 프로그램을 동시에 올려 실행할 때도 운영체제가 작용한다.
- 하드디스크에 저장, 프린터 연결 실행 등등 모두 OS의 역할
- 성능향상 및 사용자에게 편의성을 제공하는 역할도 한다



## Booting

- 컴퓨터는 프로세서 + 메인 메모리가 핵심적인 장치이고, 하드디스크라는 보조기억장치를 가지고 있다.
- 메인메모리는 RAM or ROM (대부분 RAM)
  - RAM (대부분 DRAM)
  - ROM(Read Only Memory): 많아야 수백 KB, 컴퓨터에서 약간의 ROM 필요( ex 휴대폰의 플래시 메모리)
- RAM에 있는 내용은 휘발성 메모리라 컴퓨터 전원이 꺼졌다가 켜지는 순간 날아가지만 ROM은 전원을 꺼도 내용이 유지된다. => ROM 필요한 이유!!(전원 켰을 때 실행할 명령 저장)
- 하드디스크도 전원과 관계없이 내용이 없어지지 않음. 그렇다고 ROM이 하드디스크인 것은 아니다. ROM은 메인 메모리
- 부팅 동작과정
  - 1) 전원을 키면 가장 처음으로 프로세서는 ROM안에 있는 Instruction을 읽어와서 실행
  - 2) POST(Power-On-Self-Test)가 가장 먼저 실행 => 전원을 킬 때 셀프 테스팅하는 것(환경설정이 제대로 되어 있는지, 메모리가 얼마 있는지 등 확인)
  - 3) Boot Loader 실행 => 컴퓨터는 보통 하드디스크 안에 OS를 설치함. 부트로더가 컴퓨터 켜지면 하드디스크에서  OS를 찾아 메인 메모리(RAM)로 올린다. ROM의 역할은 3단계까지
  - OS가 메인 메모리로 올라오면 바탕화면이 나오고 우리가 익숙한 화면을 볼 수 있음 => OS가 메인 메모리에 상주하면서 받는 명령을 처리할 준비가 되었다는 뜻
  - 전원을 끄면 OS도 메인 메모리에서 날아감
  - 헷갈릴 수 있는 점: 프로그램들은 실행할 때 메모리에 있다가 종료하면 메인 메모리에서 내려가는데 OS는 전원이 들어와 있는 동안은 메모리에 상주한다 => OS를 Memory Resident라고 함



## Kernal & Shell

> OS는 하드웨어를 감싸 관리 해주고 있는 형태
>
> 실제 OS가 하드웨어를 제어하고 관리하는 부분을 OS의 Kernal(핵심)이라 부름
>
> Shell은 명령을 내릴 수 있도록 만들어주는 껍데기

- Kernal: 실제 관리 프로그램 (CPU, Memory 등 관리)
- Shell: 사용자가 명령 내린 것을 해석해서 결과를 화면에 보여주는 껍질
- 커널은 관리 프로그램이라 눈에 잘 보이지 않음
- 리눅스의 CI 환경은 쉘



## etc

- 어플리케이션은 OS 위에서 실행되기 때문에 OS가 달라지면 실행 불가
- Application => OS => Hardware
- OS에는 **Processor Managerment**, **Memory Management**, IO Management, File Management, Network Management, Security or Protection Management 등 여러가지가 있음

- OS를 자원관리자(Resource Manager) 또는 자원할당자(Resource Allocator)라고도 한다 (자원 = 하드웨어)



## 역사

### 1. No OS

- 카드리더, 처리기, 프린터 등
- 동작 순서: card reader => memory => processing => printer



### 2. Batch Processing System(일괄처리) 최초의 OS

- 프로그램을 수행할 때마다 컴파일 => 로딩 순서를 오퍼레이터(사용자)가 직접 입력
- 이러한 과정을 하나의 프로그램으로 작성해 메모리에 할당하여 자동화 한것이 batch processing
- resident monitor: 메모리에 상주하며 일련의 일(컴파일, 로딩 등)을 하는 프로그램



### 3. Multiprogramming System 다중 프로그래밍

- 메모리에 여러 개의 프로그램을 올려 작업을 수행
- CPU idle 상태일 때 다른 프로그램의 연산 작업 수행
- 메모리에서 유저 프로그램 동작 시 => CPU는 빠르게 동작하나 I/O가 느림 => I/O 실행 중 CPU idle
- 프로그램 동작 순서를 정하는 CPU 스케줄링 중요
- 메모리 내에서 유저프로그램의 위치 중요
- 다른 영역의 프로그램 침범을 막기 위한 보호 중요



### 4. Time-Sharing System 시공유 시스템

- 컴퓨터 한대에 여러대의 단말(Terminal)을 연결
- Terminal: 모니터, 키보드만 존재
- CPU가 아주 빠르게 프로그램을 스위칭하며 동작(Time Sharging) => 단말 사용자는 프로그램을 연속적으로 수행하는 것처럼 느낌
- 유저간 통신 가능
- 동기화: 동시에 실행되기 때문에 실행 순서를 정해야함
- 가상 메모리: 유저가 많아지면 메인 메모리 부족 => 하드디스크의 일부를 메인 메모리처럼 사용

