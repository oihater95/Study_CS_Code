# 운영체제_(전통적 동기화문제)생산자-소비자문제

## 전통적 동기화 예제

- 전통적 동기화 예제
  - 생산자-소비자 문제(유한 버퍼 문제)
  - 공유 데이터베이스 접근
  - 식사하는 철학자 문제



### 생산자-소비자 문제

- **생산자가 데이터를 생산하면 소비자는 그것을 소비**

![image-20210516174233361](운영체제_(전통적 동기화문제)생산자-소비자문제.assets/image-20210516174233361.png)

- 예시1

  - 컴파일러가 high level 언어(c, java)를 low level 언어(어셈블리어)로 번역
  - 어셈블러는 어셈블리어를 기계어(binary, 실행코드 or object 코드)로 번역
  - 생산자: 컴파일러
  - 소비자: 어셈블러

  

- 예시2

  - 파일/웹 서버-클라이언트
  - 클라이언트가 요청하면 서버는 파일안에 있는 데이터 처리하여 응답 보내줌 (HTML 또는 DB 데이터)
  - 클라이언트는 응답받은 데이터를 활용해 화면에 보여줌
  - 생산자: 서버
  - 소비자: 클라이언트



![image-20210516174304734](운영체제_(전통적 동기화문제)생산자-소비자문제.assets/image-20210516174304734.png)

- 생산된 데이터는 버퍼에 일단 저장(생산과 소비 속도 차이 때문에 생산한 것을 바로 소비 불가)
- 소비자는 버퍼에 있는 데이터를 소비
- 현실 시스템에서 버퍼 크기는 유한 (버퍼는 메모리 또는 디스크 공간으로 만들어짐, bounded buffer)
- **생산자는 버퍼가 가득 차면 더 넣을 수 없다, 소비자는 버퍼가 비면 뺄 수 없다**
- **문제점: 생산속도와 소비속도의 차이, 유한한 크기의 버퍼**



<img src="운영체제_(전통적 동기화문제)생산자-소비자문제.assets/image-20210516174351284.png" alt="image-20210516174351284" style="zoom:120%;" />

- 코드 구현 시 버퍼는 원형 큐 구조(배열)로 구현, 생산자와 소비자는 스레드로 구현

  - 생산자는 버퍼에 n번 삽입, 소비자는 버퍼에서 n번 제거
  - 일반적인 경우라면 딱 맞게 떨어져서 문제 발생하지 않음 (버퍼안에 존재하는 데이터 수 = count, count = 0)
  - 즉, 최종적으로 버퍼 내에는 0개의 항목이 있어야 함

  


#### 문제점1, 임계 구역 동시 접근

- 잘못된 결과 (동기화 되지 않은 경우)

  - 실행 불가 또는 count ≠ 0 (생산된 항목 숫자 ≠ 소비된 항목 숫자)

  

- 원인

  - 공통 변수 count, buffer[]에 대한 동시 업데이트
  - 공통 변수 업데이트 구간(= **임계 구역 Critical Section**)**에 대한 동시 진입**

    

- 해결 방법

  - 생산자가 버퍼를 업데이트 하는 구간(임계 구역) 진입 시 소비자가 접근하지 못하도록 한다
  - 마찬가지로 소비자가 임계 구역 진입 시 생산자가 접근하지 못하도록 한다.
  - 임계 구역에 대한 동시 접근 방지(**상호 배타**)
  - 세마포를 사용한 상호 배타 (mutual exclusion)
  - 세마포: mutex.value = 1 (number of permit) => 세마포 초기값 
    - acquire() => 1만큼 감소, 0보다 작으면 큐에 넣고 block
    - release() => 1만큼 증가, 0보다 작거나 같으면 큐에서 꺼내고 해방



#### 문제점 2, Busy-wait

- 실행은 되지만 CPU 낭비가 심함

- 원인
  - 생산자: 버퍼가 가득 차면 기다려야 함, 빈 공간 생길 때까지
  - 소비자: 버퍼가 피면 채워진 공간 생길 때까지 기다려야 함
  - 버퍼 공간 문제가 해결될 때까지 CPU는 무한 루프 돌며 기다려야 함 => 낭비 발생



- 해결 방법
  - 버퍼가 가득 차면 생산자 루프를 세마포 block => 소비자에 의해 버퍼 공간 생기면 해방
  - 버퍼가 비어 있을 경우 소비자 루프를 세마포 block => 생산자에 의해 버퍼가 채워지면 해방
  - 세마포
    - 생산자: empty, 초기값 = 버퍼 사이즈(버퍼 빈 공간만큼)
    - 소비자: full, 초기값 = 0 (버퍼가 비어있기 때문에)
    - 생산자 임계 구역 진입시 empty.acquire(), 나올 때 full.release() => 생산자에 의해 소비자 해방
    - 소비자 임계 구역 진입시 full.acquire(), 나올 때 empty.release() => 소비자에 의해 생산자 해방









