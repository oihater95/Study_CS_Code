# 04_구조와 모듈

## 1. 모듈

### 1.1 스택과 활성화 레코드

#### 활성화 레코드

- 함수가 호출될 때마다 생성

- 함수의 정보(반환값, 매개변수, 지역 변수, 반환값, 반환 주소 등) 기록, 스택에 저장

- 활성화 레코드 처리 프로세스

  1) 함수의 실제 매개변수를 스택에 저장(push)

  2) 반환 주소를 스택에 저장

  3) 스택의 최상위 인덱스를 함수의 지역 변수에 필요한 총량만큼 늘린다.

  4) 함수로 건너뛴다(jump)

- 활성화 레코드 unwinding 프로세스

  1) 스택의 최상위 인덱스는 함수에 소비된 총 메모리양(지역 변수)만큼 감소

  2) 반환 주소를 스택에서 빼낸다

  3) 스택의 최상위 인덱스는 함수의 실제 매겨변수만큼 감소



### 1.2 모듈 기본값

함수 또는 메서드에서 가변 객체를 기본값으로 사용하지 않는다.

```python
def append(number, number_list=None):
    if number_list is None:
        number_list = []
    number_list.append(number)
    return number_list
```



### 1.3 `__init__.py`

패키지의 초기화 코드를 실행 또는 `__all__` 변수 정의

```python
__all__ = ['파일1', ...]
```



### 1.4 `__name__ `  변수

파이썬은 모듈을 임포트할 때마다 `__name__` 이라는 변수 만들고 모듈 이름을 저장

```python
hello = 'hello'
def world():
    return 'world'

if __name__ == '__main__':
    print('{} 직접 실행됨'.format(__name__))
else:
    print('{} 임포트됨.'.format(__name__))
    
    
import hello
>>> hello 임포트됨
hello.hello
>>> 'hello'
hlleo.world()
>>> 'world'
___name__
>>> '__main__'
$ python hello.py
>>> __main__ 직접 실행됨
```



## 2. 제어문

### 2.1 if

`if` 문은 반드시 **참/거짓을 판단할 수 있는 조건**과 함께 사용이 되어야한다.

#### if 조건문

```python
if <조건식>:  # True일 경우 if 코드동작 / False의 경우 다음 블럭으로
	코드
elif <조건식>:  # True일 경우 코드 동작 / False면 넘어감
	코드
else:  # 나머지
	코드
```

```python
# 홀수/짝수 판별
if num % 2 == 0:
	print('짝수')
else:
    print('홀수')
    
=
if num % 2:  # num % 2 = 1 => if True:
    print('홀수')
else:
    print('짝수')
```



#### Conditional Expression 조건표현식

- 조건 표현식은 일반적으로 조건에 따라 값을 정할 때 활용된다.
- **삼항 연산자(Ternary Operator)**라고 부르기도 한다.

```python
'''
우선 평가하고자 하는 expression을 먼저 쓴다 (ex: num > 0)
num > 0

expression 앞 뒤로 if와 else를 쓴다
if num > 0 else

if 왼쪽에는 if 만족 시 실행될 코드
else 오른쪽에는 else 만족 시 실행될 코드
print('양수') if num > 0 else print('음수')
'''
```

```python
# 절댓값 반환
num = int(input('숫자를 입력하세요 : '))

value = num if num >= 0 else -num
=

if num >= 0:
	value = num
else:
	value = -num
>>>
숫자를 입력하세요 : -3
3
```



### 2.2 for

- `for` 문은 시퀀스(string, tuple, list, range)나 다른 순회가능한 객체(iterable)의 요소들을 순회한다.

```python
for <임시변수> in <순회가능한데이터(iterable)>:
    <코드 블럭>
```

```python
for num in [1, 2, 3, 4, 5]:
    print(num)
print('끝')
print(num)  
>>>
1
2
3
4
5
끝
5
# python 환경에서는 num이 임시변수이지만 살아있음,  C++의 경우 null값
```



### 2.3 참과 거짓

#### True

- True
- 1(int)
- 값이 들어 있는 자료구조 (문자열, 리스트, 튜플, 딕셔너리 등)



#### False

- False
- 0 (int)
- None
- 비어있는 자료구조 (`''`, `[]`, `()`, `{}`)



### 2.4 return vs yield

#### return

- 호출자가 메서드를 호출할 때 return 키워드는 반환값을 반환하고 메서드를 종료한 후 호출자에게 제어를 반환

```python
a = [1, 2, 3]
def f(a):
    while a:
        return a.pop()
        
f(a)
>>>
3
```



#### yield

- 각 반환값을 호출자에게 반환하고, 반환값이 모두 소진 되었을 때만 메서드가 종료됨

```python
a = [1, 2, 3]
def f(a):
    while a:
        yield a.pop()
        
f(a)
>>>
3
2
1
```



### 2.5 break vs continue

#### break

- 반복문에서 `break`를 만나면 해당 반복문을 즉시 빠져나감

```python
rice = ['보리', '보리', '보리', '쌀', '보리']
for i in rice:
    print(i)
    if i == '쌀':
        print('잡았다!')
        break
>>>
보리
보리
보리
쌀
잡았다!
```



#### continue

- 반복문에서 `continue`를 만나면 반복문의 다음 단계(다음 iteration)을 진행한다.

```python
ages = [10, 23, 8, 30, 25, 31]
for i in ages:
    if i < 20:
        continue
    else:
        print(i, '살은 성인입니다.')
>>> 23 살은 성인입니다.
30 살은 성인입니다.
25 살은 성인입니다.
31 살은 성인입니다.
```



### 2.6 range()

- 숫자 리스트를 생성, 숫자 시퀀스를 순회할 때 사용 (이상, 미만, 스텝)

- 스텝의 default는 1

- 기본형 : `range(n)` == `range(0, n, 1)`
  - 0부터 n-1까지 값을 가짐

- 범위 지정 : `range(n, m)`
  - n부터 m-1까지 값을 가짐

- 범위 및 스텝 지정 : `range(n, m, s)`
  - n부터 m-1까지 +s만큼 증가한다

```python
# range 생성
range(3)
>>> range(0, 3)

type(range(3))
>>> range

# range에 담긴 것을 list로 형변환
list(range(3))
>>> [0, 1, 2]

# 0부터 -9까지 담긴 range 생성
print(list(range(0, -10, 1)))
>>> []

print(list(range(0, -10, -1)))
>>> [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
```



### 2.7 enumerate()

- 반복 가능한 객체의 인덱스 값과 항목 값의 튜플을 반환

```python
# enumerate = index와 value를 tuple로 묶음
lunch = ['짜장면', '초밥', '피자', '햄버거']
for i in enumerate(lunch):
    print(i)
>>>
(0, '짜장면')
(1, '초밥')
(2, '피자')
(3, '햄버거')

for i, menu in enumerate(lunch):
    print(i, menu)
>>>
0 짜장면
1 초밥
2 피자
3 햄버거

list(enumerate(lunch))
>>>
[(0, '짜장면'), (1, '초밥'), (2, '피자'), (3, '햄버거')]
```



### 2.8 zip()

- 2개 이상의 시퀀스를 인수로 취하여 짧은 길이의 시퀀스를 기준으로 각 항목이 순서대로 1:1 대응하는 새로운 튜플 시퀀스를 만듦

```python
girls = ['jane', 'ashley', 'mary']
boys = ['justin', 'eric', 'david']
pair = list(zip(girls, boys))
print(pair)
>>>
[('jane', 'justin'), ('ashley', 'eric'), ('mary', 'david')]
```



### 2.9 filter()

- 시퀀스 항목들 중 함수 조건이 **True**인 항목만 추출해서 구성된 시퀀스를 반환

```python
# 홀수인 요소만 뽑아 new_numbers에 저장합니다.
numbers = [1, 2, 3]
new_numbers = list(filter(odd, numbers))
print(new_numbers)
>>> [1, 3]
```



### 2.10 map()

- 시퀀스의 모든 항목에 함수를 적용한 결과 리스트를 반환

```python
numbers = [1, 2, 3]
m = list(map(str, [1, 2, 3]))  # list에 저장
list(m)
>>> ['1', '2', '3']

list(m)  # list에서 저장한 것은 여러번 가져다 쓸 수 있음
>>> ['1', '2', '3']
```



### 2.10 lambda

- 코드 내에서 함수를 간결하게 동적으로 사용

```python
a = [(1, 3), (2, 3), (1, 6)]
b = sorted(a, key=lambda (x[0]*x[1]):x[0])
print(b)
>>>
(1, 3), (1, 6), (2, 3)
```



## 3. 파일처리

### 3.1 파일처리 메서드

#### 1) open()

- open(filename, mode, encoding) => 파일 객체 반환
- mode와 encoding은 옵션
- mode
  - r: 읽기
  - w: 쓰기(이름이 같은 파일이 있다면 해당 파일을 지운 후 내용을 새로 씀)
  - a: 추가(이름이 같은 파일이 있다면 해당 파일 끝에 내용 추가)
  - r+: 읽기와 쓰기
  - t: 텍스트
  - b: 바이너리



#### 2) read()

- read(size): 파일에서 **size**만큼 내용을 읽고 **문자열**로 반환
- 텍스트 모드의 경우 문자열을 반환, 바이너리 모드의 경우 바이트 객체를 반환
- size는 정수, 선택적 인수, 인수가 생략되거나 음수이면 전체 파일 내용을 읽고 반환
- 파일의 끝에 도달하면 빈 문자열을 반환



#### 3) readline()

- 파일에서 한 줄을 읽음
- 개행 문자는 문자열의 끝에 남으며 파일의 마지막 행에서만 생략



#### 4) readlines()

- 파일의 모든 데이터 행을 포함한 리스트를 반환
- size 지정하면 파일에서 해당 바이트 수만큼 읽고 한 행을 완성하는데 필요한 만큼 더 읽어서 반환



#### 4) write()

- 데이터를 파일에 쓰고 None을 반환
- 바이너리 모드에서는 바이트 또는 바이트 배열 객체를 사용
- 텍스트 모드에서는 문자열 객체 사용



#### 5) tell(), seek()

- tell()
  - 파일의 현재 위치를 나타내는 정수를 반환
  - 파일의 위치는 시작 부분에서 바이트 단위로 측정
- seek()
  - seek(offset, from-what): 파일 내 탐색 위치를 변경할 때 사용
  - 파일 위치는 기준이 되는 참조 포인트 from-what에 offset을 더한 값으로 걔산
  - from-what 인수를 0으로 지정하면 기준이 파일의 처음 위치가 되고 1이면 파일의 현재 위치, 2이면 파일의 마지막 위치를 기준으로 함



#### 6) close()

- 파일을 닫고, 열린 파일이 차지하는 시스템 자원 해제
- 성공적으로 닫으면 True 반환



#### 7) input()

- 사용자 입력을 받는다.
- 사용자가 텍스트를 입력하고 엔터 또는 리턴 키를 누를 때까지 기다린다
- 입력안하고 엔터 누르면 빈 문자열을 반환한다
- 입력하고 엔터 누르면 해당 입력한 내용을 문자열로 반환



#### 8) peek()

- peek(n): 파일 포인터 위치를 이동하지 않고, n 바이트를 반환



#### 9) fileno()

- 파일 서술자를 반환



### 3.2 shutil 모듈

- 시스템에서 파일을 조작할 때 유용

- 터미널에서 파일 및 파일 확장자를 지정하면 새 확장자의 이름으로 복사본을 만듦

```python
import os
import sys
import shutil

def change_file_ext():
    if len(sys.argv) < 2:
        print("Usage: python {} filename.old_ext 'new_ext'".format(sys.argv[0]))
        sys.exit()
    
    name = os.path.splitext(sys.argv[1])[0] + '.' + sys.argv[2]
    print(name)
    
    try:
        shutil.copyfile(sys.argv[1], name)
    except OSError as err:
        print(err)
        
if __name__ == '__main__':
    change_file_exit()
```



### 3.3 pickle 모듈

- 파이썬 객체를 가져와서 문자열 표현으로 변환
- 직렬화
- 문자열 표현을 객체로 재구성 => unpickling



### 3.4 struct 모듈

- 파이썬 객체를 이진 표현으로 변환하거나 이진 표현을 파이썬 객체로 변환
- 객체는 특정 길이의 문자열만 처리



## 오류 처리

### 4.1 예외 처리

#### try-except

- `try` 아래의 코드블럭(code block)이 실행된다.
- 예외가 발생되지 않으면, **`except`없이 실행이 종료 된다.**
- 예외가 발생하면, **남은 부분을 수행하지 않고**, `except`가 실행된다.

```python
try:
    <코드 블럭 1>
except (예외):
    <코드 블럭 2>
```

```python
try: 
    num = input('값을 입력하시오 : ')
    print(int(num))
except ValueError:  # 에러를 특정할 수 있음
    print('숫자를 입력하라니까!!')
    
    
try:
    empty_list = []
    print(empty_list[-1])
except IndexError as err:  # 메세지 설정 가능
    print(f'{err}, 오류가 발생했습니다.')
```

```python
# 복수의 예외 처리
try:
    <코드 블럭 1>
except 예외1:
    <코드 블럭 2>
except 예외2:
    <코드 블럭 3>
    
try:
    <코드 블럭 1>
except (예외1, 예외2):  # 튜플식으로 묶어서 처리 가능
    <코드 블럭 2>
```



#### else

- 에러가 발생하지 않는 경우 수행되는 문장은 `else`를 이용한다.
- 모든 except 절 뒤에와야 한다.
- try 절이 예외를 일으키지 않을 때 실행되어야만 하는 코드에 적절하다.

```python
try:
    <코드 블럭 1>
except 예외:
    <코드 블럭 2>
else:
    <코드 블럭 3>
```



#### finally

- 반드시 수행해야하는 문장은 `finally`를 활용한다.
- 즉, 모든 상황에 실행되어야만 하는 코드를 정의하는데 활용한다.
- 예외의 발생 여부과 관계없이 try 문을 떠날 때 항상 실행한다.

```python
try:
    <코드 블럭 1>
except 예외:
    <코드 블럭 2>
finally:
    <코드 블럭 3>
```



### 4.2 Exception Raising 예외 발생 시키기

#### raise

- `raise`를 통해 예외를 강제로 발생시킬 수 있습니다.

```python
raise <에러>('메시지')
```

```python
raise ZeroDivisionError('0으로 나누지마라')
>>> ZeroDivisionError: 0으로 나누지마라
```



#### assert

- 보통 **상태를 검증하는데 사용**되며 무조건 `AssertionError`가 발생한다.

```python
assert Boolean expression, error message

assert len([1, 2]) == 1, '길이가 1이 아닙니다.'
>>>
AssertionError: 길이가 1이 아닙니다
```