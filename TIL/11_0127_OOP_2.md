# OOP **II**

## 인스턴스 변수 & 클래스 변수

### 인스턴스 변수

- 인스턴스의 속성
- 각 인스턴스들의 고유한 변수
- 메서드 정의에서 `self.변수명`으로 정의
- 인스턴스 생성 후 `instance이름.변수명`으로 접근 및 할당

```python
class Person:
    def __init__(self, name):  # 인스턴스 메서드 중 (특별한) 생성자 메서드
        self.name = name     # 인스턴스 변수를 정의 / 할당
                            # self : 인스턴스 자기 자신을 뜻함
            
kim = Person('kim')  # 인스턴스 kim 생성
kim.name  # 인스턴스이름.변수명 으로 접근
>>> 'kim'
```



### 클래스 변수

- 클래스의 속성
- 모든 인스턴스가 공유
- 클래스 선언 내부에서 정의
- `class이름.변수명`으로 접근 및 할당

```python
class Person: 
    species = 'human'  # 클래스 내에 변수를 지정 => 클래스 변수
    
Person.species  # 클래스이름.변수명으로 접근
>>> 'human'

kim = Person()  # 인스턴스 kim 생성
kim.species
>>> 'human'

kim.species = '사람'  # kim에 할당된 species 값을 변경/재할당 -> Person 클래스의 클래스변수는 그대로
kim.species # kim인스턴스의 species만 바뀜
>>> '사람'

Person.species  # 클래스 변수는 변하지 않았음
>>> 'human'

lee = Person()
lee.species
>>> 'human'
```



## 인스턴스 & 클래스 간의 이름공간

- 클래스를 정의하면 클래스가 생성됨과 동시에 이름공간(namespace) 생성
- 인스턴스 생성시 인스턴스 객체가 생성된고 해당되는 이름공간 생성
- 인스턴스의 속성이 변경되면 변경된 데이터를 인스턴스 객체 이름공간에 저장
- 인스턴스에서 특정 속성에 접근하는 것은 **인스턴스 => 클래스** 순으로 탐색

```python
class Person:
    name = 'unknown'  # 클래스 변수
    
    # 인스턴스 변수가 정의된적 없음
    def talk(self):
        print(self.name)
        
p1 = Person()  # 인스턴스 변수 없음(탐색: 인스턴스 => 클래스)
p1.talk()  # 그래서 클래스 변수 할당
>>> unknown

p1.name = 'lee'  # 인스턴스 변수 할당
print(p1.name)  # 인스턴스 변수 출력 => 인스턴스는 클래스를 이용해 생성된 새로운 객체
>>> lee

print(Person.name)  # 클래스 변수 출력
>>> unknown
```



## 메서드의 종류

### 인스턴스 메서드

- 인스턴스가 사용할 메서드
- 클래스 내부에 정의되는 메서드의 기본 값은 인스턴스 메서드
- **호출시 첫번째 인자로 인스턴스 자기자신`self`**가 전달됨

```python
class MyClass:
    def instance_method(self, arg1, arg2, ...):
        ...

my_instance = MyClass()
# 인스턴스 생성 후 메서드를 호출하면 자동으로 첫 번째 인자로 인스턴스(my_instance)가 들어감
my_instance.instance_method(.., ..)  

'''
인스턴스 메서드는 인스턴스를 조작하는 함수

kim = MyClass('kim')

실제 내부 호출
MyClass.instance_method(kim)
'''

```



### 클래스 메서드

- 클래스가 사용할 메서드
- `@classmethod` 데코레이터 사용하여 정의
- **호출 시 첫번째 인자로 클래스 `cls`가 전달됨

```python
class MyClass:
    @classmethod
    def class_method(cls, arg1, arg2, ...):
        ...

# 자동으로 첫 번째 인자로 클래스(MyClass)가 들어간다.
MyClass.class_method(.., ..)  

'''
실제 호출
MyClass.class_method(MyClass)
'''
```



### 스태틱 메서드

- 클래스가 사용할 메서드
- `@staticmethod` 데코레이터를 사용하여 정의
- **호출시, 어떠한 인자도 전달되지 않음**

```python
class MyClass:
    @staticmethod
    def static_method(arg1, arg2, ...):
        ...

# 아무런 일도 자동으로 일어나지 않는다.
MyClass.static_method(.., ..)
```

```python
class MyClass:
    
    # 인스턴스 메서드
    def instance_method(self):  # 인스턴스 메서드 첫번째 인자는 self
        return self
    
    # 클래스 메서드
    @classmethod  # decorator, cls에 클래스 넣어줌
    def class_method(cls):  # 클래스 메서드 첫번째 인자 cls, cls = MyClass
        return cls
    
    # 스태틱 메서드 => 클래스용 O, 인스턴스용 X
    @staticmethod
    def static_method(arg):  # 보통은 인자 안씀
        print('static')
        return arg
    
mc = MyClass()
mc.instance_method()  # self를 return
>>> <__main__.MyClass at 0x1538eece730>

print(id(mc), id(mc.instance_method()))  # id 동일 
print(mc == mc.instance_method())  # 인스턴스와 인스턴스메서드의 self값은 같다
>>> 1458391803696 1458391803696
True

# # 인스턴스 -> 클래스 메서드 접근 but 쓰지는 말자
# 내부적으로 인스턴스의 클래스를 추척해 cls를 넣어준다
mc.class_method()

# 인스턴스는 스태틱 메서드에 접근 가능
mc.static_method(1)  # 자동으로 넘겨주는 인자가 없기 때문에 직접 넣어야함
>>> static
1

# 클래스 -> 인스턴스 메서드 접근
# 접근은 가능 하지만 self인자역할 할 인자가 없어서 에러
MyClass.instance_method()
>>> TypeError

# 클래스 -> 인스턴스 메서드 접근 but 안하는게 좋다
MyClass.instance_method(mc)
>>> <__main__.MyClass at 0x1538eece730>

# 클래스 -> 클래스 메서드
MyClass.class_method()
>>> __main__.MyClass
```



### 비교정리

#### 인스턴스와 메서드

- 인스턴스는 3가지 메서드(인스턴스, 클래스, 스태틱) 모두 접근 가능
- 하지만 인스턴스에서 클래스 메서드와 스태틱 메서드는 호출하지 않는 것이 좋다.
- 인스턴스가 할 행동은 모두 인스턴스 메서드로 한정 지어 설계한다.



#### 클래스와 메서드

- 클래스도 3가지 메서드 모두 접근 가능
- 클래스에서 인스턴스 메서드 호출하지 않는 것이 좋다
- 클래스 자체(`cls`)와 그 속성에 접근할 필요가 있다 면 클래스 메서드로 정의
- 클래스와 클래스 속성에 접근할 필요가 없다면 정적 메서드로 정의 
- 정적메서드는 `cls`, `self`와 같이 묵시적인 첫번째 인자를 받지 않음



## 상속

### 상속





### 다중 상속





## 메서드 오버라이딩







