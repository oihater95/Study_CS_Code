# JS_practice_02

## 변수

### 변수 선언

- let

  - 변수, 재할당 가능, 재선언 불가능

  ```js
  let x = 1
  x = 2  // 재할당
  ```

  

- const

  - 상수, 재할당 불가능, 재선언 불가능
  
  ```js
  const y = 1
  y = 2  // ERROR
  
  const arr = []
  arr.push(1)  // 가능, 재할당아님 (arr = 1은 불가능 => 재할당)
  ```
  
  

- var
  - 재할당, 재선언 가능
  - 호이스팅 문제로 안씀

  

### Scope

> 기본적으로 JS는 블록 스코프

- 블록 안에서 바깥은 참조 가능
- 블록 바깥에서 안쪽은 참조 불가능

```js
if (true) {  // 블록 스코프 === {} 영역
  let y = 2
}
console.log(y)  // ReferneceError y is not defined

let x = 1
const greeting = 'hello'
if (true) {
  console.log(greeting)  // 'hello'  => 블록 안에서 바깥을 참조는 가능
  let z = 3
  let x = 2
}
console.log(x)  // 1
console.log(z)  // ReferneceError z is not defined, 블록 밖에서 블록 안 내용 참조는 불가능
```



  ### Convention

- camelCase === lowerCamelCase
  - 변수, 상수, 함수명



- PascalCase === UpperCamelCase
  - class명



- UPPER_SNAKE_CASE
  - 절대 변하면 안되는 상수 값

  

## 타입

### Number

- 숫자

  - 정수
  - 실수
  - 무한대, -무한대
  - NaN(Not a Number): 산술연산자 좌우의 타입이 숫자가 아닐 때

  ```js
  console.log(
    1, -1, 3.14, 2.998e3, Infinity, -Infinity, 10 / 0, 10/'a', 'a'*'b', 1 + NaN
  )
  [출력]
  1, -1, 3.14, 2998, Infinity(무한대), -Infinity(-무한대), Infinity, NaN, NaN, NaN
  ```

  ```js
  function add(n1, n2) {
    return n1 + n2
  }
  add(1, 2, 3)  // 3 => 1 + 2
  add(1)  // NaN => 1 + NaN
  ```

  

### String

- 문자열

  - `''` or`""` 로 감싸진 문자열
  - Concatenation 지원
  - Template Literal: f string과 같은 기능 따옴표 대신 백팁(`)사용, 변수로 넣을 {}앞에 $사용
  - 문자열 + 숫자 = 문자열: JS는 에러지양언어, 숫자를 문자열로 변환하여 강제 concatenation

  ```js
  console.log(
    'String Type: ',
    'hello', "world", 'abc'+'def',  // ', " 모두 가능, concatenation 지원
    `1 + 1 = ${1 + 1}`,  // "1 + 1 = 2" => Template Literal = f string, 따옴표 대신 백팁(`)사용
    'aaa' + 12,  // 'aaa12' 강제 concatenation => JS는 에러지양언어
  )
  ```

  

### Empty

- 공백

  - undefined: 의도치 않음, 모르는 값, 함수의 리턴 값이 없을 때 undefined 반환
  - null: 의도적으로 비운 값, 없는 값

  ```js
  let a = null
  const dict = {'a': 1}
  dict['b']  // keyError 대신에 undefined
  ```

  

### Boolean

- `true` or `false`

  ```js
  1 === '1'  // false
  1 == '1'  // true => 1을 문자열 '1'로 변환, 최대한 true 나오게끔
  Boolean([])  // true
  Boolean({})  // true
  Boolean('') // false
  Boolean(0)  // false
  ```

  

## 연산자

### 단항연산자

- 항 1개 필요

- `-`: 부호 바꿈
- `typeof`: 타입 리턴
- `++`: += 1, `--`: -= 1
- `!`: not (논리 연산자)

```js
let i = 1
console.log(i++)  // i에 대한 평가가 끝난 후, 1을 더한다
console.log(++i)  // i에 대한 평가 전에 1을 더한다.
```



### 이항 연산자

- 항 두개 필요

- `+`, `-`, `*`, `/`, `%` 등 산술 연산자

- `>`, `>=`, `<=`, `<` 등 수 비교 연산자
- `+=`, `/=` 등
- `&&`: and, `||`: or 등 논리 연산자

```js
console.log(!'')  // true
// 단축평가
console.log('asd' && 0 && [])  // 0
console.log(0 || '1' || '')  // '1'
```



### 삼항 연산자

- 항 3개 필요
- `?` true일 경우 `:` false 일 경우

```js
// 가치평가 
console.log(1 > 2 ? '크다' : '작다')  // 작다
console.log('' ? 'empty' : 'not empty')  // not empty, ''는 false지만 null은 아님

let num = 1
const even_or_odd = num % 2 ? 'odd' : 'even'
console.log(even_or_odd)  // odd
```



### 동등/일치 연산자

- 동등 `==`: 사용하지 않음, 넘겨 짚어 판단

```js
0 == '0'  // true
0 == []  // true
'0' == []  // false
```



- 일치 `===`: python의 `==`와 같다 (불일치 `!==`)

```js
0 === '0'  // false
0 === []  // false
'0' === []  // false
1 === 1  // true
1 !== 2  // true
```



## 조건문

```js
const id = 'admin'
```



### if

- if 조건 **true**이면 if 블록 실행
- false이면 else if의 조건 판단 후 true이면 else if 실행
- false이면 else 실행
- 조건이 여러가지 일 때 사용

```js
if (id === 'admin') {
  console.log('관리자님, 환영합니다')
} else if (id === 'manager') {
  console.log('매니저님, 환영합니다')
} else {
  console.log(`${id}님, 환영합니다`)
}
```



### switch

- 조건이 한가지일 때 사용
- 조건이 true인 case로 이동 후 실행
- case마다 break없으면 맞는 케이스만 동작하는 하는 것이 아니고 맞는 케이스부터 끝까지 다 순회함

```js
switch (id) {
  case 'admin': {
    console.log('관리자님, 환영합니다')
    break
  }
  case 'manager': {
    console.log('매니저님, 환영합니다')
    break
  }
  default: {  // else
    console.log(`${id}님, 환영합니다`)
  }
}
```



## 반복문

### while

- while문의 조건문이 true일 경우 반복
- 인덱스를 while문 블록 안에서 처리해야함

```js
let i = 0
while (i < 5) {
  console.log(i)
  i++
}  // 0 1 2 3 4
```



### for

- for문 조건에서 인덱스도 처리

```js
for (let j=0; j<5; j++) {
  console.log('hi')
}  // hi 5번 출력
```



- 요소를 꺼내는 for - of (Array) => in은 Object에서 사용

```js
const numbers = [1, 2, 3, 4, 5]
// 요소를 꺼내는 for - of (Array)
for (const number of numbers) {  // let number 말고 const number로 사용, 한번 순회할 때마다 블록자체가 소멸하고 생성되어서 const가능, 재할당이 아닌 생성
  console.log(number)
}
```



- 인덱스 접근

```js
for (let k=0; k<numbers.length; k++) {
  console.log(numbers[k])
}
```



- Object => of 로 순회하면 TypeError 발생
  - Object(dict)는 not iterable

```js
const person = {name: 'kim', address: 'seoul'}  // key는 string으로 자동으로 판단하기 때문에 ''안써도 됨
for (const a of person) {  // TypeError: person is not iterable
  console.log(person[a])
}
```



- Object 순회 in

```js
// Object(Dict) => key 꺼내는 for - in
for (const key in person) {
  console.log(person[key])
}
```



- Object key 접근

```js
// Object의 key는 속성처럼 사용가능
person.name  // "kim"
person.address  // "seoul"
```



## 함수

> 선언 먼저하고 호출하기

### 선언식

```js
function add(n1, n2) {
  return n1 + n2
}
```



### 표현식

> function () {} vs () => {} 는 내부에 this 키워드가 있으면 다르게 동작, 이외에는 모두 같음

#### function 키워드

```js
const sub = function (n1, n2) {
  return n1 - n2
}
```



#### Arrow Function

1. function 키워드를 지운다

2. () {} 사이에 => 를 넣는다

 <optional>

3. 인자가 딱 1개라면, 괄호 생략 가능

4. 블록 안에 return 구문만 있으면 {}와 return 모두 삭제 가능

```js
let cube = function (n) { 
    return n ** 3
  }

// 1, 2 적용
cube = (n) => {
  return n ** 3
}

// 3, 4 적용
cube = n => n ** 3

// 인자 1개가 아닐 경우 3 적용 불가
mul = (n1, n2) => n1 * n2
// 인자 없는 경우
printer = () => console.log('hi')
```



## 배열
- 리스트로 구현되어 있음 => 크기 제한 없음
- 음수 인덱싱, 슬라이싱 불가



```js
let numbers = [1, 2, 3, 4]
numbers[0]  // 1
numbers[-1]  // 음수 인덱스 사용 불가
// numbers[1:3]  // 슬라이싱 불가능
numbers.length  // 배열의 길이 반환
```



### .reverse()

- 역순으로 배치 바꿈

- 원본 자체를 바꾸고 바꾼 원본을 반환

```js
numbers.reverse()  // [4, 3, 2, 1]
numbers  // [4, 3, 2, 1]
```



### .push()

- 마지막 인덱스 뒤에 요소를 삽입 = append
- 원본 자체를 바꾸고 **바꾼 원본의 length를 반환**

```js
numbers = [1, 2, 3, 4]
numbers.push(10)  // 5 => numbers.length를 반환
numbers  // [1, 2, 3, 4, 10]
```



### .pop()

- 가장 마지막 인덱스를 삭제하고 삭제한 요소 값을 반환

```js
numbers.pop()  // 10 => pop한 결과 (가장 마지막 인덱스를 pop)
numbers  // [1, 2, 3, 4]
```



### .unshift()

- 맨 앞에 요소 삽입 = insert(value, 0)
- 원본을 바꾸고 **바꾼 원본의 길이를 반환**

```js
numbers.unshift('a')  // 5 => numbers.length를 반환
numbers  // ['a', 1, 2, 3, 4] 
```



### .shift()

- 맨 앞의 요소를 삭제 = dequeue popleft()
- 삭제한 요소를 반환

```js
numbers.shift()  // 'a', shift(dequeue) 한 결과 = popleft()
numbers  // [1, 2, 3, 4]
```



### .includes()

- 인자가 배열 안에 존재하는지 확인, python의 in과 같음
- 반환은 true or false
- 원본 건드리지 않음

```js
numbers.includes(4)  // true
numbers  // 변화 없음
```



### .indexOf()

- 해당 요소의 인덱스를 반환 = .index()
- **존재하지 않는 경우 -1을 반환**
- 원본 건드리지 않음

```js
numbers.indexOf(2)  // 1 => 해당 요소의 인덱스를 반환
numbers.indexOf(1000)  // -1 => 해당 배열에 존재하지 않는 경우 -1을 반환
numbers  // 변화 없음
```



### .join()

- 배열의 각 요소를 인자로 연결하고 string 으로 반환
- 원본은 건드리지 않음
- 숫자 배열의 경우 문자열로 변환 후 수행

```js
numbers.join('-')  // '1-2-3-4' 숫자로 되어 있는 numbers의 요소들을 String으로 변환하고 join
numbers  // 변화 없음
```



## 객체 Object

- {key: value} => Python Dictionary와 비슷
- python dictionary와 차이점
  - key 문자열의 따옴표 삭제 가능(띄어쓰기 없을 때) => 띄어쓰기 존재하면 따옴표 써야함, but 변수명처럼 대문자써서 붙여쓰기 권장
  - 접근할 때 , ['key']와 .key모두 가능

```js
const me = {
  name: 'kim',
  phoneNumber: '01012345678',
  friends: [
    'park', 'lee', 'choi'
  ],
  home: {
    address: '서울',
    owner: 'KIM',
  }
}
```



- ES6+ 축약 문법

```js
const books = ['LearningJs', 'EloquentJS']
const magazines = ['GQ', 'esquire']
const bookshop = {  // key와 value가 같으면 key만 써줌
  books,
  magazines,
}
```

```js
const dooly = {  
  name: 'dooly',
  // Arrow Function
  greeting1: () => console.log('도우너,'),
  // Function 키워드 대체용
  greeting2 () {
    console.log('어서오고')
  }
}
```



- computed property name => 잘 안씀

```js
const key = 'regions'
const value = ['서울', '부산', '대구', '광주', '울산', '인천']
const metrocity = {
  [key]: value
}
metrocity.regions
```



- Object Destructuring 비구조화 => 변수명과 key값 같을 때

```js
const userInfo = {
  name: 'kim',
  email: 'kimkim@gmail.com',
  phone: '01012345678',
}
// const name = { userInfo }
// const email = { userInfo }
// const phone = { userInfo }
const { name, email, phone } = userInfo

function printInfo(name, email, phone) {
  console.log(`안녕 나는 ${name} ${email} ${phone}`)
}
printInfo(userInfo)
```



## JSON

- Java Script Object Notation

- **JSON은 String**

```js
const obj = {
  coffee: 'Americano',
  iceCream: 'Cookie&Cream',
}

const jsonData = JSON.stringify(obj)  // JSON은 String
const backToObj = JSON.parse(jsonData)
```



## Array Helper Methods

### .forEach

- return 되는 값 없음 === 콜백 함수에 return 필요없음
- for - of 의 대체제

```js
const arr = [1, 2, 3]
arr.forEach(function (num) { 
  console.log(num)
})  // 1 2 3 undefined
```



### .map()

- 콜백 함수의 리턴값으로 만든 배열을 리턴

```js
arr.map(function (num) {
  return num * 2
})  // [2, 4, 6]

arr.map(num => num * 2)  // [2, 4, 6]
```



### .find()

- 콜백 함수의 리턴 값이 true 또는 true로 평가되는 **첫번째 요소만 리턴**

```js
arr.find(function (num) {
  return num === 2
})  // num === 2인 첫번째 요소 반환

arr.find(num => num === 2)  // num === 2인 첫번째 요소 반환

const articles = [
  {pk: 1, title: 'hi'},
  {pk: 2, title: 'hello'},
  {pk: 3, title: '안녕'},
]
articles.find(article => article.pk === 3)  // pk가 3인 첫번째 요소 리턴
```



### .filter()

- 콜백 함수의 리턴 값이 true 또는 true로 평가되는 요소만 **배열로 리턴**

```js
arr.filter(num => num % 2)  // 홀수만 리턴
const movies = [
  {title: 'matrix', isAdult: false},
  {title: 'kingsman', isAdult: true},
]

const adultMovies = movies.filter(movie => movie.isAdult)  // isAdult true만 리턴
```



### .some() & .every()

- .some(): 배열 안의 요소가 하나라도 만족하면 return true, 아닐 경우 false
- .every(): 배열 안의 요소가 모두 만족하면 return true, 아닐 경우 false

```js
arr.every(num => num > 0)  // true true true => true
arr.every(num => num > 1)  // false true true => false
arr.some(num => num % 2)  // true false true => true
arr.some(num => num > 100)  // false false false => false
```



### .reduce(cb, initValue)

- .reduce() 인자 2개 필요, cb도 인자 2개 필요
- initValue를 매번 콜백의 인자로 넣음 => 재귀 개념과 비슷
- return 값이 acc에 들어감

```js
arr.reduce(function (acc, num) {  // acc => accumulator
  console.log(`acc: ${acc}`)
  console.log(`num: ${num}`)
  return '무야호'
}, 0)  // acc의 initValue = 0
/*
acc: 0
num: 1
acc: 무야호
num: 2
acc: 무야호
num: 3
"무야호"
*/
```

```js
arr.reduce(function (acc, num) {  // acc => accumulator
  console.log(acc, num)
  return acc + num  
}, 0)  // acc = 0
/*
0 1
1 2
3 3
6
*/
```

```js
arr.reduce(function (acc, num) {  // acc => accumulator
    console.log(acc, num)
  acc.push(num * 2)
  return acc
}, [])  // acc = []
/*
[] 1
[2] 2
(2) [2, 4] 3
(3) [2, 4, 6]
*/
```

