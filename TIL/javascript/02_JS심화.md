# JS 심화

## AJAX

> Asynchronous JS(비동기식 JS) + XML

- 서버와 통신하기 위해 **XMLHttpRequest** 객체 활용
  - XMLHttpRequest는 동기식과 비동기식 통신 모두 지원
- 페이지 전체를 reload 하지 않고서도 수행되는 비동기성
  - 사용자의 event가 있으면 전체 페이지가 아닌 일부분만을 업데이트
- 최근에는 XML보다 용량이 더 가벼운 JSON을 더 많이 사용



### XMLHttpRequest object

- 서버와 상호작용하기 위해 사용되며, 전체 페이지의 새로고침 없이 URL로부터 데이터를 받앙로 수 있음
- 사용자가 하는 것을 방해하지 않으면서 페이지의 일부를 업데이트
- AJAX 프로그래밍에 사용
- XML 뿐만 아니라 모든 종류의 데이터를 받아오는데 사용 가능
- 생성자
  - XMLHttpRequest()

```js
const request = new XMLHttpRequest()
const URL = 'https://jsonplaceholder.typicode.com/todos/1/'

request.open('GET', URL)
request.send()

const todo = request.response
console.log(todo)
```



## Asynchronous JS

### 동기식

- 순차적, 직렬적 task 수행
- **요청을 보낸 후 응답을 받아야만** 다음 동작이 이루어짐 (blocking)



### 비동기식

- 병렬적 task 수행
- **요청을 보낸 후 응답을 기다리지 않고 다음 동작이 이루어짐(non-blocking)**
  - 요청 보내놓고 다음 task로 진행



### 비동기 사용 이유

- 사용자 경험 예시

  - 데이터를 구동하고 실행되는 앱 존재, 데이터 크기가 굉장히 크다고 가정
  - 동기식 코드라면 데이터를 모두 로드한 뒤에야 앱이 실행되기 때문에 로드되는 동안 앱을 사용할 수 없느 상태로 얼마나 걸릴지 모르는 로딩 시간을 기다려야함
  - 앱이 모두 멈춘것처럼 보임
- 동기식 요청은 코드 실행을 차단하여 화면이 멈추고 응답하지 않는 사용자 경험 만듦
- 많은 앱 API 기능은 현재 비동기 코드를 사용하여 실행



### 동기식 예시

```html
<button>버튼</button>
<script>
	const btn = document.querySelector('button')
    btn.addEventListener('click', function() {
        alert.('You clicked')
        const pElem = document.createElement('p')
        pElem.innerText = 'sample text'
        document.body.appendChild(pElem)
    })
</script>
```



- 버튼 클릭 후 alert 메시지의 확인 버튼을 누를 때까지 문장이 만들어지지 않음
- alert 이후의 코드는 alert의 처리가 끝날 때까지 실행되지 않음
- 이런 현상 발생이유: JS는 single threaded



### 비동기식 예시

- 요청을 보내고 응답을 기다리지 않고 다음 코드 실행됨
- 결과적으로 변수 todo에는 응답 데이터가 할당되지 않고 빈 문자열이 출력
- JS가 기다려주지 않는 방식으로 동작하는 이유: JS는 single threaded

```js
const request = new XMLHttpRequest()
const URL = 'https://jsonplaceholder.typicode.com/todos/1/'

request.open('GET', URL)
request.send()  // 요청을 보내고 다음 코드로 넘어감

const todo = request.response  // 아직 응답이 오지 않음
console.log(todo)  // undefined 출력
```



### Blocking vs Non Blocking

- Python(Blocking)
  - 요청에 대한 response를 기다림
  - JS의 for문은 blocking



- JS(Non Blocking)
  - 요청에 대한 response를 기다리지 않고 넘어감
  - 바로 빈 문자열 출력하고 응답에 대한 처리를 나중에함



### Threads

- 프로그램이 작업을 완료하는데 사용할 수 있는 단일 프로세스
- 각 스레드는 한번에 하나의 작업만 수행할 수 있음
- 예시
  - Task A => Task B => Task C
  - 다음 작업을 시작하려면 반드시 앞의 작업이 완료되어야함
  - CPU는 여러 코어를 가지고 있기 때문에 한번에 여러가지 일을 처리 가능



#### JS의 Single Thread

- 컴퓨터가 여러 개의 CPU를 가지고 있어도 main thread라 불리는 단일 스레드에서만 작업 수행
- 이벤트 처리하는 **Call Stack**이 하나인 언어
- 이 문제를 해결하기 위해 JS는 즉시 처리하지 못하는 이벤트들은 **다른 곳(Web API)**으로 보내서 처리
- 처리된 이벤트들은 처리된 순서대로 **대기실(Task Queue)**에 줄을 세워 둠
- Call Stack이 비면 **담당자(Event Loop)**가 대기 줄에서 가장 오래된 (제일 앞) 이벤트를 Call Stack으로 보냄



### Concurrency Model

- Event Loop를 기반으로 하는 동시성 모델
  - Call stack
  - Web API(Browser API)
  - Task Qeueu (Event Queue, Message Queue)
  - Event Loop



#### Call Stack

- 요청이 들어올 때마다 해당 요청을 순차적으로 처리하는 Stack(LIFO)형태의 자료구조



#### Web API (Browser API)

- JS 엔진이 아닌 브라우저 영역에서 제공하는 API (브라우저에서 처리)
- setTimeout(), DOM events, AJAX로 데이터를 가져오는 시간이 소요되는 일들을 처리
- setTimeout(function ~~~, 3000) => 3초 후에 출력이 아니고 3초 후에 Task Queue에 들어가는 것
- 처리 요청 오는대로 바로 처리 (A 처리중에 B오면 A와 B모두 처리)
- 어떤 요청이 먼저 왔든 먼처 처리 끝난 요청을 Task Queue로 보냄

```js
console.log(1)
setTimeout(function () {
    console.log('Hi')
    setTimeout(function () {
    console.log("TIMEOUT!");
    }, 7000);
    setTimeout(function () {
    console.log("OUT!");
    }, 2000);
    
}, 5000);

setTimeout(function () {
        console.log('timeout');
    }, 1000);

>>>
1
timeout
Hi
OUT
TIMEOUT
```



#### Task Queue (Event Queue, Message Queue)

- 콜백 함수가 대기하는 Queue(FIFO)형태의 자료 구조
- main thread가 끝난 후 실행되어 후속 JS코드가 차단되는 것을 방지



#### Event Loop

- Call Stack이 비어 있는지 여부를 확인

- 비어 있는 경우 Task Queue에서 실행 대기중인 콜백이 있는지 확인
- Task Queue에 대기중인 콜백이 있다면 **가장 앞에 있는 콜백**(FIFO)을 Call Stack으로 push



### Zero delays

- 실제로 0ms 후 콜백이 시작된다는 의미 아님, Task Queue에 0초 후 들어간다(밀려있지 않다면)
- 실행은 Task Queue에 대기중인 작업 수에 따라 다르다
- delay는 JS가 요청을 처리하는데 필요한 최소 시간이기 때문(**보장된 시간 아님**)
- 기본적으로 setTimeout은 setTimeout에 대한 특정 시간 제한을 지정했더라도 대기중인 메시지의 모든 코드가 완료될 때까지 대기해야함



## 순차적인 비동기 처리

- Web API로 들어오는 순서는 중요하지 않고 어떤 이벤트가 **먼저** 처리  되느냐가 중요 (실행 순서 불명확)
- 이를 해결하기 위해 순차적인 비동기 처리를 위한 2가지 작성 방식



#### Async callbacks

- 백그라운드에서 실행을 시작할 함수를 호출할 때 인자로 지정된 함수
- 예시) addEventListener()의 두번째 인자 (예시: 클릭하면 콜백 => 보장)



#### promise-style

- Modern Web APIs에서 새로운 코드 스타일
- XMLHttpRequest보다 조금 더 현대적인 버전





## Callback Function

- 다른 함수에 인자로 전달된 함수
- 외부 함수 내에서 호출되어 일종의 루틴 또는 작업을 완료함
- 동기식, 비동기식 모두 사용됨
- 비동기 작업이 완료된 후 코드 실행을 계속하는 데 사용되는 경우 비동기 콜백이라함



### 일급 객체 First-class object

> 일급 객체 (일급 함수)

- 다른 객체들에 적용 가능한 연산을 모두 지원하느 객체(함수)
- 일급 객체의 조건
  - 인자로 넘길 수 있어야함
  - 함수의 반환 값으로 사용할 수 있어야함
  - 변수에 할당할 수 있어야함



### 비동기 콜백

- 백그라운드에서 코드 실행을 시작할 함수를 호출할 때 인자로 지정된 함수
- 백그라운드 코드 실행이 끝나면 콜백 함수를 호출하여 작업이 완료되었음을 알리거나, 다음 작업을 실행하게 할 수 있음



### 콜백을 사용하는 이유

- 콜백 함수는 명시적인 호출이 아닌 특정 루틴 또는 행위에 의해 호출되는 함수
- Django의 경우 요청이 들어오면, event의 경우 특정 이벤트가 발생하면 이라는 조건 하에 함수를 호출할 수 있었던 건 'Callback Funtion'메커니즘이 있기 때문에 가능
- 비동기 로직을 수행할 때 콜백 함수는 필수
  - 명시적인 호출이 아닌 특정 시점에서 알아서 호출되도록 만들어야하기 때문이며 기다려주지 않고 언젠가 처리해야 하는 일은 콜백 함수를 활용



### Callback Hell

> pyramid of doom (파멸의 피라미드)

- 순차적인 연쇄 비동기 작업을 처리하기 위해 콜백 함수를 호출하고, 그 다음 콜백 함수를  호출하고 또 호출하고 ... 패턴이 지속적으로 반복됨
- 여러 개의 연쇄 비동기 작업을 할 때 마주하는 상황
- 디버깅하기 어렵고 코드 가독성이 매우 떨어짐
- 해결 방법
  - 코드의 깊이를 얕게 유지
  - 모듈화
  - 모든 단일 오류 처리
  - **Promise way (promise 방식 사용)**



## Promise

### promise object

- 비동기 작업의 최종 완료 또는 실패를 나타내는 객체  (성공 => 데이터, 실패 => 에러)
  - 미래의 완료 또는 실패와 그 결과 값을 나타냄
  - 미래의 어떤 상황에 대한 약속
- 성공(이행)에 대한 약속, 성공하면 실행할 것
  - .then()
- 실패(거절)에 대한 약속, 실패하면 실행할 것
  - .catch()



### promise 상태

- 대기 pending
  - 이행하거나 거부되지 않는 초기 상태
- 이행 fulfilled
  - 연산이 성공적으로 완료됨
- 거부 rejected
  - 연산이 실패함



### promise methods

> promise => 비동기

```js
const myPromise = new Promise((resolve, reject) => {
    setTimeout(function () {
        resolve('성공!')
    }, 300)
})

myPromise  // 줄바꿈 후 .then .catch
	.then(function (response) {
    console.log('YES' + response)
	})
	.catch(function (error) {
    console.log('실패!' + error)
})
```



- 각각의 .then() 블록은 서로 다른 promise를 반환
  - .then()을 여러 개 사용 (chaining)하여 연쇄적인 작업을 수행할 수 있음 => 깊이 깊어지지 않게 함, callback hell 방지
  - 결국 여러 비동기 작업을 차례대로 수행할 수 있다
- .then(), .catch() 메서드는 모두 promise를 반환하기 때문에 chaining 가능

- 주의

  - 반환 값이 반드시 있어야함
  - 없다면 콜백 함수가 이전의 promise 결과를 받을 수 없다

  

#### .then(callback)

- 이전 작업(promise)이 성공했을 때 수행할 작업을 나타내는 콜백 함수 (promise.then(callback) => promise가 성공하면 콜백 함수 수행)
- 각 콜백 함수는 이전 작업(promise)의 성공 결과를 인자로 전달 받음
- 성공했을 때의 코드를 콜백 함수 안에 작성



#### .catch(callback)

- .then이 하나라도 실패하면 동작 (동기식의 'try except 구문과 유사')
- 이전 작업의 실패로 인해 생성된 error 객체는 catch 블록 안에서 사용할 수 있다



#### .finally(callback)

- Promise 객체를 반환
- 결과에 상관없이 무조건 지정된 콜백 함수가 실행
- 어떠한 인자도 전달 받지 않음
  - Promise가 성공했는지 실패했는지 판단할 수 없기 때문
- 무조건 실행되어야 하는 절에서 사용
  - .then()과 .catch() 블록에서의 코드 중복 방지



###  Promise가 보장하는 것

- Async callback 작성 스타일과 달리 Promise가 보장하는 특징
- 콜백은 JS Event Loop가 현재 실행중인 Call Stack을 완료하기 이전에는 절대 호출되지 않음
  - Promise 콜백은 event queue에 배치되는 엄격한 순서로 호출됨
- 비동기 작업이 성공하거나 실패한 뒤에 .then() 메서드를 이용하여 추가한 경우에도 위와 같이 동작
- .then()을 여러반 사용하여 여러개의 콜백을 추가할 수 있음 Chaning
  - 각각의 콜백은 주어진 순서대로 하나 하나 실행하게 됨
  - Chaining은 Promise의 가장 뛰어난 장점



## Axios

- Promise based **HTTP client** for the browser and Node.js => Promise 반환, 요청
- 브라우저를 위한 Promise 기반의 클라이언트
- 원래는 XHR이라는 브라우저 내장 객체를 활용해 AJAX 요청을 처리하는데 이보다 편리한 AJAX 요청이 가능하도록 도움을 줌
  - 확장 가능한 인터페이스와 함께 패기지로 사용이 간편한 라이브러리 제공

```js
axios.get('https://jsonplaceholder.typicode.com/todos/1/')  // Promise return
	// return된 Promise 객체는 .then과 .catch에서 받음
	.then(...)
    .catch(...)
```



### XHL -> Axios

```js
// XHL
const request = new XMLHttpRequest()
const URL = 'https://jsonplaceholder.typicode.com/todos/1/'

request.open('GET', URL)
request.send()

const todo = request.response
console.log(todo)

// Axios
const URL = 'https://jsonplaceholder.typicode.com/todos/1/'

axios.get(URL)
	.then(function (response) {
    console.log(response.data)
	})
```



- Axios 예시

```js
const URL = 'https://jsonplaceholder.typicode.com/todos/1/'

axios.get(URL)
	.then(function (response) {
    return response.data
	})
	// chaining
	.then(function (data) {  // data = 위의 response.data
    return data.title
	})
    .then(function (title) {  // title = 위의 data.title
    console.log(title)
	})
	.catch(function (error) {
    console.log(error)
	})
	.finally(function () {  // finally는 성공, 실패 상관없기 때문에 인자 없음
    console.log('이건 무조건 실행')
	})
```



### async & await

- 비동기 코드 작성 새로운 방법
- 기존 Promise 시스템 위에 구축된 syntactic sugar
  - Promise 구조의 then chaining 제거
- syntactic sugar
  - 문법적 기능은 그대로 유지, 가독성 좋아짐